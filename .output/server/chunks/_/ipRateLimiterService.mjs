import t,{Schema as e}from"mongoose";import{f as r}from"./nitro.mjs";const n=new e({ip:{type:String,required:!0,unique:!0},count:{type:Number,required:!0,default:1},lastRequest:{type:Date,required:!0,default:Date.now},windowStart:{type:Date,required:!0,default:Date.now}},{timestamps:!0});n.index({lastRequest:1},{expireAfterSeconds:7200});var i=Object.defineProperty,__publicField=(t,e,r)=>((t,e,r)=>e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r)(t,"symbol"!=typeof e?e+"":e,r);let s={};class IpRateLimiterService{constructor(e,r="ip_requests"){__publicField(this,"RATE_LIMIT",20),__publicField(this,"WINDOW",36e5),__publicField(this,"IpRequest"),this.RATE_LIMIT=e?25:5,s[r]?this.IpRequest=s[r]:(this.IpRequest=t.model(r,n),s[r]=this.IpRequest)}async checkRateLimit(t){try{await r();const e=new Date((new Date).getTime()-this.WINDOW),n=await this.IpRequest.findOne({ip:t});return!n||(n.windowStart<e||!(n.count>=this.RATE_LIMIT))}catch(t){return console.error("Error checking rate limit:",t),!0}}async getRequestCount(t){let e={count:0,max:this.RATE_LIMIT,restartsIn:0};try{await r();const n=await this.IpRequest.findOne({ip:t});if(!n)return e;const i=new Date,s=new Date(i.getTime()-this.WINDOW);if(n.windowStart<s)return e;const a=Math.max(0,Math.ceil((n.windowStart.getTime()+this.WINDOW-i.getTime())/1e3));return{count:n.count,max:this.RATE_LIMIT,restartsIn:a}}catch(t){return console.error("Error getting request count:",t),e}}async incrementSuccessfulRequest(t){try{await r();const e=new Date,n=new Date(e.getTime()-this.WINDOW);await this.IpRequest.findOneAndUpdate({ip:t},[{$set:{count:{$cond:{if:{$or:[{$not:["$windowStart"]},{$lt:["$windowStart",n]}]},then:1,else:{$add:["$count",1]}}},windowStart:{$cond:{if:{$or:[{$not:["$windowStart"]},{$lt:["$windowStart",n]}]},then:e,else:"$windowStart"}},lastRequest:e,ip:t}}],{upsert:!0,new:!0,setDefaultsOnInsert:!0});return!0}catch(t){return console.error("Error incrementing successful request count:",t),!1}}async canMakeRequest(t){try{await r();const e=new Date((new Date).getTime()-this.WINDOW),n=await this.IpRequest.findOne({ip:t});return!n||(n.windowStart<e||!(n.count>=this.RATE_LIMIT))}catch(t){return console.error("Error checking if request can be made:",t),!0}}async cleanupOldRecords(){try{await r();const t=new Date(Date.now()-2*this.WINDOW);await this.IpRequest.deleteMany({lastRequest:{$lt:t}})}catch(t){console.error("Error cleaning up old records:",t)}}}export{IpRateLimiterService as I};
//# sourceMappingURL=ipRateLimiterService.mjs.map
