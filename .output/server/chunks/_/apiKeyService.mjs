import e,{Schema as t}from"mongoose";import{f as s,x as a,y as i,z as r,A as n}from"./nitro.mjs";const c=new t({userId:{type:String,required:!0,unique:!0,index:!0,trim:!0,maxlength:128},encryptedApiKey:{type:String,required:!0,trim:!0},iv:{type:String,required:!0,trim:!0},authTag:{type:String,required:!0,trim:!0},apiKeyHash:{type:String,required:!0,trim:!0},lastSaved:{type:Date,required:!0,default:Date.now,index:!0},isActive:{type:Boolean,required:!0,default:!0,index:!0},metadata:{userAgent:{type:String,maxlength:500},ipAddress:{type:String,maxlength:45},platform:{type:String,maxlength:100}},rateLimitInfo:{requestLimit:{type:Number,min:0},requestRemaining:{type:Number,min:0},requestReset:{type:Number,min:0},lastUpdated:{type:Date,default:Date.now}}},{timestamps:!0,collection:"api_keys"});c.index({userId:1,isActive:1}),c.index({lastSaved:-1}),c.index({createdAt:-1}),c.pre("save",(function(e){(this.isModified("encryptedApiKey")||this.isModified("apiKeyHash"))&&(this.lastSaved=new Date),e()})),c.methods.toSafeObject=function(){const e=this.toObject();return delete e.encryptedApiKey,delete e.iv,delete e.authTag,delete e.apiKeyHash,e},c.statics.findByUserId=function(e){return this.findOne({userId:e,isActive:!0})},c.statics.deactivateByUserId=function(e){return this.updateOne({userId:e},{isActive:!1,lastSaved:new Date})},c.statics.getActiveCount=function(){return this.countDocuments({isActive:!0})},c.statics.cleanupInactive=function(e=30){const t=new Date;return t.setDate(t.getDate()-e),this.deleteMany({isActive:!1,updatedAt:{$lt:t}})};const u=e.models.ApiKey||e.model("ApiKey",c);async function saveApiKey(e,t,a){try{if(!e||"string"!=typeof e)return{success:!1,message:"Invalid user ID"};const c=i(t);if(!c.isValid)return{success:!1,message:c.error||"Invalid API key"};await s();const{encryptedData:d,iv:o,authTag:y}=r(t.trim()),l=await n(t.trim()),p=new Date,m=await u.findOne({userId:e});if(m)return m.encryptedApiKey!=d&&(m.rateLimitInfo=null),m.encryptedApiKey=d,m.iv=o,m.isActive=!0,m.authTag=y,m.apiKeyHash=l,m.lastSaved=p,m.metadata=a,await m.save(),{success:!0,message:"API key updated successfully",lastSaved:m.lastSaved};{const t=new u({userId:e,encryptedApiKey:d,iv:o,authTag:y,apiKeyHash:l,lastSaved:p,isActive:!0,metadata:a});return await t.save(),{success:!0,message:"API key saved successfully",lastSaved:t.lastSaved}}}catch(e){return console.error("❌ Error saving API key:",e),{success:!1,message:"Failed to save API key. Please try again."}}}async function getApiKey(e){try{if(!e||"string"!=typeof e)return{success:!1,message:"Invalid user ID"};await s();const t=await u.findOne({userId:e,isActive:!0});if(!t)return{success:!1,message:"No API key found for this user"};try{return{success:!0,apiKey:a(t.encryptedApiKey,t.iv,t.authTag),lastSaved:t.lastSaved,rateLimitInfo:t.rateLimitInfo}}catch(e){return console.error("❌ Error decrypting API key:",e),{success:!1,message:"Failed to decrypt API key. The key may be corrupted."}}}catch(e){return console.error("❌ Error getting API key:",e),{success:!1,message:"Failed to retrieve API key. Please try again."}}}async function deleteApiKey(e){try{if(!e||"string"!=typeof e)return{success:!1,message:"Invalid user ID"};await s();return 0===(await u.updateOne({userId:e,isActive:!0},{isActive:!1,lastSaved:new Date,encryptedApiKey:"",iv:"",authTag:"",apiKeyHash:"",rateLimitInfo:null})).matchedCount?{success:!1,message:"No active API key found for this user"}:{success:!0,message:"API key deleted successfully"}}catch(e){return console.error("❌ Error deleting API key:",e),{success:!1,message:"Failed to delete API key. Please try again."}}}async function hasApiKey(e){try{if(!e||"string"!=typeof e)return{hasKey:!1};await s();const t=await u.findOne({userId:e,isActive:!0},{lastSaved:1});return{hasKey:!!t,lastSaved:null==t?void 0:t.lastSaved}}catch(e){return console.error("❌ Error checking API key existence:",e),{hasKey:!1}}}async function getApiKeyStats(){try{await s();const e=new Date;e.setDate(e.getDate()-1);const[t,a,i]=await Promise.all([u.countDocuments({isActive:!0}),u.countDocuments({isActive:!1}),u.countDocuments({isActive:!0,lastSaved:{$gte:e}})]);return{totalActiveKeys:t,totalInactiveKeys:a,recentlyUpdated:i}}catch(e){return console.error("❌ Error getting API key stats:",e),{totalActiveKeys:0,totalInactiveKeys:0,recentlyUpdated:0}}}async function updateRateLimitInfo(e,t){try{if(!e||"string"!=typeof e)return{success:!1,message:"Invalid user ID"};await s();return 0===(await u.updateOne({userId:e},{$set:{rateLimitInfo:{...t,lastUpdated:new Date}}})).matchedCount?{success:!1,message:"No active API key found for this user"}:{success:!0,message:"Rate limit information updated successfully"}}catch(e){return console.error("❌ Error updating rate limit info:",e),{success:!1,message:"Failed to update rate limit information"}}}export{getApiKey as a,deleteApiKey as d,getApiKeyStats as g,hasApiKey as h,saveApiKey as s,updateRateLimitInfo as u};
//# sourceMappingURL=apiKeyService.mjs.map
