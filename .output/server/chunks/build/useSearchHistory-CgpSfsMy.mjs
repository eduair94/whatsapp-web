import{ref as e}from"vue";var r=Object.defineProperty,u=(e,t,o)=>((e,t,o)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o)(e,"symbol"!=typeof t?t+"":t,o);new class{constructor(){u(this,"dbName","WhatsAppSearchHistory"),u(this,"storeName","searches"),u(this,"version",1),u(this,"db",null)}async init(){if(this.isIndexedDBSupported())return new Promise(((e,r)=>{const t=indexedDB.open(this.dbName,this.version);t.onerror=()=>{console.error("Failed to open IndexedDB:",t.error),r(t.error)},t.onsuccess=()=>{this.db=t.result,e()},t.onupgradeneeded=e=>{const r=e.target.result;if(!r.objectStoreNames.contains(this.storeName)){const e=r.createObjectStore(this.storeName,{keyPath:"id"});e.createIndex("phoneNumber","phoneNumber",{unique:!1}),e.createIndex("searchDate","searchDate",{unique:!1})}}}));console.log("IndexedDB not supported, falling back to localStorage")}isIndexedDBSupported(){return!1}async addSearch(e){return this.db?this.addOrUpdateIndexedDBOptimized(e):this.addOrUpdateLocalStorage({...e,id:`${e.phoneNumber}_${Date.now()}`,searchDate:new Date})}async getSearchHistory(){return this.db?this.getFromIndexedDB():this.getFromLocalStorage()}async clearHistory(){return this.db?this.clearIndexedDB():this.clearLocalStorage()}async deleteSearch(e){return this.db?this.deleteFromIndexedDB(e):this.deleteFromLocalStorage(e)}async addOrUpdateIndexedDBOptimized(e){return new Promise(((r,t)=>{const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),a=o.index("phoneNumber").get(e.phoneNumber);a.onsuccess=()=>{const s=a.result,n=new Date,c={...e,id:s?s.id:`${e.phoneNumber}_${Date.now()}`,searchDate:n.toISOString(),data:JSON.parse(JSON.stringify(e.data))},i=o.put(c);i.onsuccess=()=>r(),i.onerror=()=>t(i.error)},a.onerror=()=>t(a.error)}))}async addOrUpdateIndexedDB(e,r){return new Promise(((t,o)=>{const a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),s={...e,searchDate:e.searchDate instanceof Date?e.searchDate.toISOString():e.searchDate,data:JSON.parse(JSON.stringify(e.data))},n=r?a.put(s):a.add(s);n.onsuccess=()=>t(),n.onerror=()=>o(n.error)}))}async getFromIndexedDB(){return new Promise(((e,r)=>{const t=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).index("searchDate").openCursor(null,"prev"),o=[];t.onsuccess=()=>{const r=t.result;if(r){const e=r.value;o.push({...e,searchDate:new Date(e.searchDate)}),r.continue()}else e(o)},t.onerror=()=>r(t.error)}))}async clearIndexedDB(){return new Promise(((e,r)=>{const t=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();t.onsuccess=()=>e(),t.onerror=()=>r(t.error)}))}async deleteFromIndexedDB(e){return new Promise(((r,t)=>{const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(e);o.onsuccess=()=>r(),o.onerror=()=>t(o.error)}))}addOrUpdateLocalStorage(e){try{const r=localStorage.getItem("whatsapp_search_history"),t=(r?JSON.parse(r):[]).filter((r=>r.phoneNumber!==e.phoneNumber));t.unshift(e);const o=t.slice(0,100);localStorage.setItem("whatsapp_search_history",JSON.stringify(o))}catch(e){console.error("Failed to save to localStorage:",e)}}getFromLocalStorage(){try{const e=localStorage.getItem("whatsapp_search_history");return e?JSON.parse(e).map((e=>({...e,searchDate:new Date(e.searchDate)}))).sort(((e,r)=>r.searchDate.getTime()-e.searchDate.getTime())):[]}catch(e){return console.error("Failed to get from localStorage:",e),[]}}clearLocalStorage(){try{localStorage.removeItem("whatsapp_search_history")}catch(e){console.error("Failed to clear localStorage:",e)}}deleteFromLocalStorage(e){try{const r=localStorage.getItem("whatsapp_search_history");if(!r)return;const t=JSON.parse(r).filter((r=>r.id!==e));localStorage.setItem("whatsapp_search_history",JSON.stringify(t))}catch(e){console.error("Failed to delete from localStorage:",e)}}};const I=()=>{const r=e([]),t=e(!1),o=e(null);return{searchHistory:r,loading:t,error:o,initializeStorage:async()=>{},addSearchToHistory:async(e,r)=>{},loadSearchHistory:async()=>{},clearAllHistory:async()=>{},deleteSearchItem:async e=>{},downloadImage:async(e,r="profile.jpeg")=>{if(e)try{const t=await(await fetch(e)).blob(),o=URL.createObjectURL(t),a=(void 0).createElement("a");a.href=o,a.style.display="none",a.download=r,(void 0).body.appendChild(a),a.click(),(void 0).body.removeChild(a),URL.revokeObjectURL(o)}catch(e){console.error("Failed to download image:",e),o.value="Failed to download image"}}}};export{I};
//# sourceMappingURL=useSearchHistory-CgpSfsMy.mjs.map
